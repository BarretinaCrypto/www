### Specification: Recursive Length Prefix Encoding

Recursive length prefix encoding is a way of serializing data into the form of a string. RLP encoding can encode either strings or arrays of arbitrary length, dimension and depth; associative arrays are not natively supported. RLP encoding is defined in two parts. First, we define a method called `num_to_var_int` which converts a number into 1-9 bytes using a prefix-free encoding - that is, given the start of a `var_int` there is only one place that `var_int` could end. If the integer is below 253, the `var_int` is just the corresponding byte; otherwise, depending on the integer's size, the integer is stored in 2-byte, 4-byte or 8-byte binary form and an initial byte of 253, 254 or 255 is used to specify which length is used. Here is the definition in code:

    def to_binary(x,bytes):
        if bytes == 0:     return ''
        else:              return to_binary(int(x / 256), bytes - 1) + chr(x % 256)

    def num_to_var_int(x):
        if x < 253:        return chr(int)
        else if x < 2**16: return chr(253) + to_binary(x,2)
        else if x < 2**32: return chr(253) + to_binary(x,4)
        else:              return chr(253) + to_binary(x,8)

Examples:

    > to_binary(128)
    '\x80'
    > to_binary(252)
    '\xfc'
    > to_binary(253)
    '\xfd\x00\xfd'
    > to_binary(1024)
    '\xfd\x04\x00'
    > to_binary(2147483647)
    '\xfe\x7f\xff\xff\xff'

And now we define the actual `rlp_encode` method. The encoding is simple: for strings, it's just `'\x00' + num_to_var_int(s.length) + s`, and for arrays we first recursively RLP encode each item in the array, then concatenate these encodings together, and take the RLP encoding of that as a string, but using `'\x01'` as the beginning byte instead of `'\x00'`. 

    def rlp_encode(obj):
        if isinstance(obj,str):
            return '\x00' + num_to_var_int(len(obj)) + obj
        elif isinstance(obj,list):
            x = ''.join([rlp_encode(x) for x in obj])
            return '\x01' + num_to_var_int(len(x)) + x

Examples:

    > rlp_encode('dog')
    '\x00\x03dog'

    > rlp_encode(['dog','god','cat'])
    '\x01\x0fx00\x03dog\x00\x03god\x00\x03cat'

    > rlp_encode([[['doge'],'dog'],'do'])
    '\x01\x13\x01\x0d\x01\x06\x00\x04doge\x00\x03dog\x00\x02do'


