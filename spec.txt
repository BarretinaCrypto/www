## Ethereum: Components

The Ethereum client will be built in a modular fashion, containing several parts:

### Networking daemon

**Purpose**: the networking daemon must be able to connect to other Ethereum nodes, and accept and share data, so as to serve as the backbone for the Ethereum network. The daemon itself should be as neutral as possible; ideally, it should be useful as part of any currency or cryptographic protocol without modification. It should include anti-DDoS features; perhaps maintain a running score preventing any single IP from making more than one request per second.

**Interface**:

- every time the daemon receives a new message (ie. `H(M)` is not equal to `H(Mprev)` for any `Mprev` received previously), it should send a POST request to `http://localhost:<outputport>` containing the data, where `outputport` can be set in the `~/.ethereum/ethereum.conf` file (default 1242 if not set)
- the daemon should listen on port `inputport`, where `inputport` can be set in the `~/.ethereum/ethereum.conf` file (default 1243 if not set), and if it receives a message in a post request it should push the data out to all connected nodes in the network.

**Dependencies:** internet, bootstrapping nodes

### Block class

**Purpose**: the block class should be able to parse blocks, serialize blocks and handle certain updating operations to blocks.

**Interface**:

- `deserialize: string -> void (constructor)`
- `get_balance: number address -> number`
- `get_contract_state: number address, number index -> number`
- `update_balance: number address, number newbalance -> void`
- `update_contract_state: number address, number index, number newvalue -> void`
- `get_contract_size: number address -> number`
- `serialize: void -> string`

**Dependencies**: database

### Transaction class


**Purpose**: the transaction class should be able to parse transactions, sign transactions and serialize transactions. Note that the serialize method should fail for transactions without a signature; transactions that are created inside a block and not deserialized should never actually be stored or serialized in any form.

**Interface**:

- `deserialize: string -> void (constructor)`
- `sign: privkey -> void`
- `serialize: void -> string`
- `create: number address, number value, number fee, array[number] data -> void (constructor)`
- `hash: void -> number`
- `to, from, value, fee, data` (accessible and settable member variables)

**Dependencies**: none

### Message class


**Purpose**: the message class should be a data storage object for messages

**Interface**:

- `create: string type, array[string] params -> void (constructor)`
- `type, params` (accessible member variables)

### Data parser

**Purpose**: determine if data is a valid transaction, valid block, valid message or invalid, and if the data is valid it should convert the data into an object of the correct class.

**Interface**:

- class Object = Block || Transaction || Message || null
- parse: string -> Object

**Dependencies**: Block class, Transaction class, Message class

### State updater

**Purpose**: take a state, a list of pending transactions, and a timestamp. Then, perform the following steps:

1. Calculate the new difficulty based on the given timestamp, the previous state's difficulty and the previous state's timestamp.
2. Continue running EVALSTEP (a function which evaluates the first transaction in the state) until the number of pending transactions becomes zero.
3. Send the block reward to the coinbase address, split the block reward for each sibling 90/10 between the sibling and the miner, and and distribute the total fees among the previous 64 miners (including siblings), sending the remainder (0-63 wei) to the last miner. Return the new state.

**Interface**:

- `update(state, transactions, timestamp) -> void`

**Dependencies**: database

### Message responder

**Purpose**: the message responder should be able to respond to network messages. Accepted message types are:

1. `getobj` - gets the object (block, transaction, transaction list, sibling list, Merkle trie node) with the specified hash. This is basically a database query.
2. `getbalance` - gets the balance of a given address at the current block
3. `getcontractroot` - gets the root of a given contract at the current block
4. `getcontractsize` - gets the size of a given contract at the current block
5. `getcontractstate` - gets the state of a given contract at a given index at the current closk

**Interface**:

- `evalMessage(msg) -> number/string`.

**Dependencies**: Block class, Message class, database

### Miner

**Purpose**: given the header of a previous block, try to make a valid proof of work for the next block

**Interface**:

- `compute_pow: string (block header) -> nonce`

**Dependencies**: none

### Manager

**Purpose**: pull all of the above components together into a working node.

**Interface**: none

**Dependencies**: database, networking daemon, parser, Block class, Transaction class, Message class, state updater

### Wallet

**Purpose**: provide a higher-level interface to Ethereum sending and receiving

**Interface**:

- `generate_receiving_address: void -> number`
- `send: number to, number value, number fee, optional array[number] data -> void`
- `mkcontract: array[number] data -> void`

**Dependencies**: networking daemon

### Block Explorer

**Purpose**: provide an interface to retrieving address balances, transactions and contract states

**Interface**: all message responder methods

**Dependencies**: networking daemon
